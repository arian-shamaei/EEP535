//In the game of Mastermind,
//This module determines how many of each kind of digit (00, 01, 10, 11) are in the passcode 
//The passcode consists of eight bits representing four base 4 numbers
//Thus, each pair of bits represents one base 4 number

//Note that use of "=" means that lines of code are executed sequentially (in an always block)
//Use of "<=" means that lines of code are executed in parallel (in an always block)

//digit0 stores how many pairs of bits in the passcode represent the number 0 (=00)
//digit1 stores how many pairs of bits in the passcode represent the number 1 (=01)
//digit2 stores how many pairs of bits in the passcode represent the number 2 (=10)
//digit3 stores how many pairs of bits in the passcode represent the number 3 (=11)


module createBuckets(LFSR, Clock, Reset, digit0, digit1, digit2, digit3, doneSignal);

input logic Clock, Reset;
input logic [1:0] LFSR [0:3]; //The random number generator module (LFSR) generated four 2-bit numbers that are passed into this module
output logic [1:0] digit0, digit1, digit2, digit3; //Each 2-bit number can have values 0, 1, 2, or 3; the number of 0's is stored in digit0; number of 1'is in digit1, etc.
logic [2:0] i; //internal variable used to bin the number of 0's, 1's, 2's, and 3's into digit0, digit1, digit2, digit3
logic [1:0] digit [0:3]; //internal variables that keep track of how many of each number occur in the passcode
output logic doneSignal;


// 
always_ff @(posedge Clock) begin 
	if (Reset) begin	
		//When Reset is activated (i.e., set = 1), reset i, doneSignal, and all digits to 0
		//Note that, because of the use of <=, all bits are set simultaneously to 0 (in parallel)
		//The use of <= accurately represents what happens in hardware
		//At the positive edge of the clock, all outputs change simultaneously, not sequentially
		doneSignal <= 0;
		i <= 3'b000;
		digit[0] <= 2'b00;
		digit[1] <= 2'b00;
		digit[2] <= 2'b00;
		digit[3] <= 2'b00;
	end
	
	else begin //Do the following if Reset is no longer active
		if (i < 4) begin  // for i = 0, 1, 2, 3
			//create bins for each digit that keeps track of how many of each digit occur in the passcode
			
			//for example, if the passcode is 1 1 2 2  = LFSR[3] LFSR[2] LFSR[1] LFSR[0]
			
			//when i = 0, then digit[LFSR[0]] takes on the value of digit[LFSR[0]] + 1 
			//digit [2] = digit[2] + 1 = 1

			//when i = 1, then digit[LFSR[1]] takes on the value of digit[LFSR[1]] + 1 
			//digit [2] = digit[2] + 1 = 2

			//when i = 2, then digit[LFSR[2]] takes on the value of digit[LFSR[2]] + 1 
			//digit [1] = digit[1] + 1 = 1

			//when i = 3, then digit[LFSR[3]] takes on the value of digit[LFSR[3]] + 1 
			//digit [1] = digit[1] + 1 = 2

						digit[0] = 0; //There were no zero's in the passcode
			digit[1] = 2; //There were two 1's in the passcode
			digit[2] = 2; //There were two 2's in the passcode
			digit[1] = 0; //There were zero 3's in the passcode

			digit[LFSR[i]] <= digit[LFSR[i]] + 1;// 0 1 2 3 3 is LFSR[0].  LFSR[0]=3; digit[3] = digit[3]+1; //clever/fix comments
			i <= i + 1;
			doneSignal <= 0;
		end
		else begin
			//and when i = 4
			//set doneSignal=1 after all four digits in the passcode have been counted and binned
			doneSignal <= 1;  
		end
	end
end
 

//assign the digit[] values to the outputs of the module digit0, digit1, digit2, digit3
assign digit0 = digit[0];
assign digit1 = digit[1];
assign digit2 = digit[2];
assign digit3 = digit[3];

endmodule

module createBuckets_testbench();
	logic Clock, Reset;
	logic [1: 0] LFSR [0:3];
	logic [2:0] digit0, digit1, digit2, digit3;
	logic doneSignal;

	createBuckets dut (.*);
	parameter CLOCK_PERIOD = 100; // sets clock period to 100 time units for simulation purposes
		
	initial begin 
		Clock <= 0;
		forever #(CLOCK_PERIOD/2) Clock <= ~Clock; //causes the clock to have 50% duty cycle (on half the time, off half the tie)
	end
		
	initial begin
		//Tests binning for the passcode 1333
		//A more thorough simulation would include more test cases
   		LFSR[0] <= 2'b01;LFSR[1] <= 2'b11; LFSR[2] <= 2'b11;LFSR[3] <= 2'b11; Reset <= 0; 	@(posedge Clock);
													@(posedge Clock);
		Reset <= 1; 										@(posedge Clock);
													@(posedge Clock);
		Reset <= 0;										@(posedge Clock);
													@(posedge Clock);
																
																										
	
	
		
	 $stop; // End the simulation.
 	end
endmodule